<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URL to JPG Converter - Fal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 50%, #0f0f0f 100%);
            min-height: 100vh;
            padding: 60px 20px;
            color: #ffffff;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(99, 102, 241, 0.1) 0%, transparent 50%);
            animation: rotate 30s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 60px;
        }

        h1 {
            font-size: 3.5em;
            font-weight: 700;
            background: linear-gradient(135deg, #ffffff 0%, #a0a0a0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            letter-spacing: -2px;
        }

        .subtitle {
            color: #888888;
            font-size: 1.1em;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        .card {
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 35px;
            margin-bottom: 25px;
            transition: all 0.3s ease;
        }

        .card:hover {
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }

        .info-box {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .info-box p {
            margin: 8px 0;
            font-size: 14px;
            color: #b0b0b0;
            line-height: 1.7;
        }

        .info-box strong {
            color: #ffffff;
            font-weight: 600;
        }

        label {
            display: block;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 0.95em;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        textarea {
            width: 100%;
            min-height: 100px;
            max-height: 500px;
            padding: 25px;
            background: rgba(20, 20, 20, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            font-size: 14px;
            font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
            resize: vertical;
            transition: all 0.3s ease;
            color: #ffffff;
            line-height: 1.8;
        }

        textarea:focus {
            outline: none;
            border-color: rgba(99, 102, 241, 0.5);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
            background: rgba(20, 20, 20, 0.95);
        }

        textarea::placeholder {
            color: #555555;
        }

        .button-group {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 15px;
            margin-top: 30px;
        }

        button {
            padding: 18px 35px;
            font-size: 15px;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            font-family: inherit;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button span {
            position: relative;
            z-index: 1;
        }

        .btn-convert {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: #ffffff;
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.3);
        }

        .btn-convert:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 15px 40px rgba(99, 102, 241, 0.4);
        }

        .btn-convert:disabled {
            background: rgba(100, 100, 100, 0.3);
            box-shadow: none;
            cursor: not-allowed;
            color: #666666;
        }

        .btn-clear {
            background: rgba(255, 255, 255, 0.05);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn-clear:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .progress-section {
            display: none;
            margin: 40px 0;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #6366f1 0%, #8b5cf6 100%);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
            position: relative;
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.5);
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            text-align: center;
            color: #888888;
            font-size: 14px;
            font-weight: 500;
        }

        .results-section {
            display: none;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
        }

        .results-title {
            font-size: 1.8em;
            font-weight: 700;
            color: #ffffff;
            letter-spacing: -0.5px;
        }

        .stats {
            display: flex;
            gap: 30px;
            font-size: 14px;
            font-weight: 600;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-number {
            font-size: 24px;
            font-weight: 700;
        }

        .stat-success {
            color: #10b981;
        }

        .stat-error {
            color: #ef4444;
        }

        .stat-label {
            color: #888888;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-download-all {
            width: 100%;
            padding: 20px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: #ffffff;
            border: none;
            border-radius: 12px;
            margin-bottom: 30px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.3);
        }

        .btn-download-all:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 15px 40px rgba(16, 185, 129, 0.4);
        }

        .btn-download-all:disabled {
            background: rgba(100, 100, 100, 0.3);
            box-shadow: none;
            cursor: not-allowed;
            color: #666666;
        }

        .result-item {
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .result-item:hover {
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .result-item.success {
            border-left: 3px solid #10b981;
        }

        .result-item.error {
            border-left: 3px solid #ef4444;
        }

        .result-url {
            font-size: 13px;
            color: #888888;
            word-break: break-all;
            margin-bottom: 15px;
            font-family: 'SF Mono', 'Monaco', monospace;
            line-height: 1.6;
        }

        .result-status {
            display: inline-block;
            font-size: 11px;
            margin-bottom: 15px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 6px 12px;
            border-radius: 20px;
        }

        .result-status.success {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .result-status.error {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .result-actions {
            display: flex;
            gap: 10px;
        }

        .btn-small {
            padding: 12px 24px;
            font-size: 13px;
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            border-radius: 8px;
        }

        .btn-small:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn-small:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn-small.primary {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border: none;
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.3);
            position: relative;
            overflow: hidden;
        }

        .btn-small.primary:hover:not(:disabled) {
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
        }

        .btn-small.primary .progress-bar-inline {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.5);
            width: 0%;
            transition: width 0.3s ease;
        }

        .btn-small.primary .btn-text {
            position: relative;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-small.primary .progress-info {
            font-size: 10px;
            opacity: 0.8;
            font-weight: 500;
        }

        .error-message {
            color: #ef4444;
            font-size: 12px;
            margin-top: 12px;
            padding: 15px;
            background: rgba(239, 68, 68, 0.1);
            border-left: 3px solid #ef4444;
            border-radius: 8px;
            font-family: 'SF Mono', monospace;
            line-height: 1.6;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Loading animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading {
            animation: pulse 1.5s ease-in-out infinite;
        }

        /* Responsive */
        @media (max-width: 768px) {
            body {
                padding: 30px 15px;
            }

            h1 {
                font-size: 2.5em;
            }

            .button-group {
                grid-template-columns: 1fr;
            }

            .results-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 20px;
            }

            .stats {
                width: 100%;
                justify-content: space-between;
            }

            .result-actions {
                flex-direction: column;
            }

            .btn-small {
                width: 100%;
            }

            .card {
                padding: 25px;
            }
        }

        /* Selection color */
        ::selection {
            background: rgba(99, 102, 241, 0.3);
            color: #ffffff;
        }

        /* Focus visible */
        *:focus-visible {
            outline: 2px solid rgba(99, 102, 241, 0.5);
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>URL to JPG</h1>
            <p class="subtitle">Transform image URLs into downloadable files</p>
        </header>

        <div class="info-box">
            <p><strong>How it works</strong></p>
            <p>Paste your image URLs (one per line) → Click Convert All → Download individually or as ZIP</p>
            <p><strong>Note:</strong> All images preserve their original dimensions. Smart delay: 1s for <10 URLs, 2s for 10+ URLs.</p>
        </div>

        <div class="card">
            <label for="urlInput">Image URLs</label>
            <textarea 
                id="urlInput" 
                placeholder="https://example.com/image1.jpg
https://example.com/image2.png
https://example.com/image3.jpg"
            ></textarea>

            <div class="button-group">
                <button class="btn-convert" id="convertBtn">
                    <span>Convert All</span>
                </button>
                <button class="btn-clear" id="clearBtn">
                    <span>Clear</span>
                </button>
            </div>
        </div>

        <div class="progress-section" id="progressSection">
            <div class="progress-bar-container">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <p class="progress-text" id="progressText">Processing...</p>
        </div>

        <div class="results-section" id="resultsSection">
            <div class="results-header">
                <h2 class="results-title">Results</h2>
                <div class="stats">
                    <div class="stat-item">
                        <div>
                            <div class="stat-number stat-success" id="successCount">0</div>
                            <div class="stat-label">Success</div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div>
                            <div class="stat-number stat-error" id="errorCount">0</div>
                            <div class="stat-label">Failed</div>
                        </div>
                    </div>
                </div>
            </div>

            <button class="btn-download-all" id="downloadAllBtn">
                Download All as ZIP
            </button>
            
            <div id="resultsContainer"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
        // Hidden settings (optimized for speed)
        const SETTINGS = {
            timeout: 15,        // 15s timeout for fast method switching
            retryCount: 2       // 2 retries is enough
        };

        const urlInput = document.getElementById('urlInput');
        const convertBtn = document.getElementById('convertBtn');
        const clearBtn = document.getElementById('clearBtn');
        const progressSection = document.getElementById('progressSection');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const resultsSection = document.getElementById('resultsSection');
        const resultsContainer = document.getElementById('resultsContainer');
        const downloadAllBtn = document.getElementById('downloadAllBtn');

        let results = [];
        let isProcessing = false;

        const CORS_PROXIES = [
            url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
            url => `https://corsproxy.io/?${encodeURIComponent(url)}`,
            url => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
        ];

        function isImageUrl(url) {
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg'];
            return imageExtensions.some(ext => url.toLowerCase().includes(ext));
        }

        function fetchWithTimeout(url, options = {}, timeout = 60000) {
            return Promise.race([
                fetch(url, options),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Timeout')), timeout)
                )
            ]);
        }

        async function downloadImage(url, filename, retries = SETTINGS.retryCount, progressCallback = null) {
            const timeoutMs = SETTINGS.timeout * 1000;
            const startTime = Date.now();
            console.log(`[${filename}] Download attempt (${retries} retries left)`);

            const updateProgress = (method, status) => {
                if (progressCallback) {
                    const elapsed = Math.round((Date.now() - startTime) / 1000);
                    progressCallback(method, status, elapsed);
                }
            };

            // Direct fetch
            try {
                updateProgress('Direct Fetch', 'trying');
                const response = await fetchWithTimeout(url, {
                    mode: 'cors',
                    credentials: 'omit',
                    cache: 'no-cache'
                }, timeoutMs);
                
                if (response.ok) {
                    const blob = await response.blob();
                    if (blob.size > 0) {
                        console.log(`[${filename}] Direct success`);
                        updateProgress('Direct Fetch', 'success');
                        saveAs(blob, filename);
                        return { success: true };
                    }
                }
            } catch (error) {
                console.log(`[${filename}] Direct failed:`, error.message);
                updateProgress('Direct Fetch', 'failed');
            }

            // CORS proxies
            for (let i = 0; i < CORS_PROXIES.length; i++) {
                try {
                    updateProgress(`Proxy ${i+1}`, 'trying');
                    const proxyUrl = CORS_PROXIES[i](url);
                    const response = await fetchWithTimeout(proxyUrl, { cache: 'no-cache' }, timeoutMs);
                    
                    if (response.ok) {
                        const blob = await response.blob();
                        if (blob.size > 0) {
                            console.log(`[${filename}] Proxy ${i+1} success`);
                            updateProgress(`Proxy ${i+1}`, 'success');
                            saveAs(blob, filename);
                            return { success: true };
                        }
                    }
                } catch (error) {
                    console.log(`[${filename}] Proxy ${i+1} failed:`, error.message);
                    updateProgress(`Proxy ${i+1}`, 'failed');
                }
            }

            // Canvas method
            if (isImageUrl(url)) {
                try {
                    updateProgress('Canvas Method', 'trying');
                    await downloadViaCanvas(url, filename, timeoutMs);
                    console.log(`[${filename}] Canvas success`);
                    updateProgress('Canvas Method', 'success');
                    return { success: true };
                } catch (error) {
                    console.log(`[${filename}] Canvas failed:`, error.message);
                    updateProgress('Canvas Method', 'failed');
                }
            }

            // Blob URL
            try {
                updateProgress('Blob URL', 'trying');
                const proxyUrl = CORS_PROXIES[0](url);
                const response = await fetchWithTimeout(proxyUrl, {}, timeoutMs);
                const blob = await response.blob();
                
                if (blob.size > 0) {
                    const blobUrl = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = blobUrl;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    setTimeout(() => URL.revokeObjectURL(blobUrl), 100);
                    console.log(`[${filename}] Blob URL success`);
                    updateProgress('Blob URL', 'success');
                    return { success: true };
                }
            } catch (error) {
                console.log(`[${filename}] Blob URL failed:`, error.message);
                updateProgress('Blob URL', 'failed');
            }

            // Retry with shorter delay (0.5s instead of 2s for individual downloads)
            if (retries > 0) {
                console.log(`[${filename}] Retrying...`);
                updateProgress('Retrying', 'waiting');
                await new Promise(resolve => setTimeout(resolve, 500));
                return downloadImage(url, filename, retries - 1, progressCallback);
            }

            console.error(`[${filename}] All methods failed`);
            updateProgress('All Methods', 'failed');
            return { 
                success: false, 
                error: 'Download failed after multiple attempts'
            };
        }

        function downloadViaCanvas(imageUrl, filename, timeout) {
            return new Promise((resolve, reject) => {
                const timer = setTimeout(() => reject(new Error('Canvas timeout')), timeout);
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = function() {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        canvas.toBlob(function(blob) {
                            clearTimeout(timer);
                            if (blob && blob.size > 0) {
                                saveAs(blob, filename);
                                resolve();
                            } else {
                                reject(new Error('Empty blob'));
                            }
                        }, 'image/jpeg', 0.95);
                    } catch (error) {
                        clearTimeout(timer);
                        reject(error);
                    }
                };
                
                img.onerror = () => {
                    clearTimeout(timer);
                    reject(new Error('Image load failed'));
                };
                
                img.src = CORS_PROXIES[0](imageUrl);
            });
        }

        function sanitizeFilename(url) {
            try {
                const urlObj = new URL(url);
                let filename = urlObj.pathname.split('/').pop() || 'image';
                filename = filename.replace(/[^a-z0-9._-]/gi, '_');
                if (!filename.match(/\.(jpg|jpeg|png|gif|webp)$/i)) {
                    filename += '.jpg';
                }
                return filename;
            } catch {
                return 'image.jpg';
            }
        }

        function viewImage(url) {
            window.open(url, '_blank');
        }

        async function convertURLs() {
            if (isProcessing) return;

            const urls = urlInput.value.trim().split('\n').filter(url => url.trim() !== '');
            
            if (urls.length === 0) {
                alert('Please enter at least one URL');
                return;
            }

            const invalidUrls = urls.filter(url => {
                try {
                    new URL(url.trim());
                    return false;
                } catch {
                    return true;
                }
            });

            if (invalidUrls.length > 0) {
                alert(`Invalid URLs found:\n${invalidUrls.slice(0, 3).join('\n')}${invalidUrls.length > 3 ? '\n...' : ''}`);
                return;
            }

            // Dynamic delay based on batch size
            const dynamicDelay = urls.length < 10 ? 1 : 2;

            if (urls.length > 100) {
                const minutes = Math.ceil(urls.length * dynamicDelay / 60);
                if (!confirm(`Converting ${urls.length} URLs\nEstimated time: ~${minutes} minutes\n\nDon't close this tab!\n\nContinue?`)) {
                    return;
                }
            } else if (urls.length > 50) {
                const minutes = Math.ceil(urls.length * dynamicDelay / 60);
                if (!confirm(`Converting ${urls.length} URLs (~${minutes} minutes)\n\nContinue?`)) {
                    return;
                }
            }

            isProcessing = true;
            results = [];
            resultsContainer.innerHTML = '';
            resultsSection.style.display = 'none';
            progressSection.style.display = 'block';
            convertBtn.disabled = true;

            let successCount = 0;
            let errorCount = 0;

            for (let i = 0; i < urls.length; i++) {
                const url = urls[i].trim();
                const progress = ((i + 1) / urls.length * 100).toFixed(0);
                
                progressFill.style.width = progress + '%';
                progressText.textContent = `Processing ${i + 1} of ${urls.length} (${successCount} success, ${errorCount} failed)`;

                try {
                    if (i > 0 && dynamicDelay > 0) {
                        await new Promise(resolve => setTimeout(resolve, dynamicDelay * 1000));
                    }

                    results.push({
                        url: url,
                        screenshot: url,
                        type: 'direct',
                        success: true
                    });

                    successCount++;

                } catch (error) {
                    results.push({
                        url: url,
                        success: false,
                        error: error.message
                    });
                    errorCount++;
                }
            }

            displayResults();
            updateStats();
            isProcessing = false;
            convertBtn.disabled = false;
        }

        function updateStats() {
            const successCount = results.filter(r => r.success).length;
            const errorCount = results.filter(r => !r.success).length;
            
            document.getElementById('successCount').textContent = successCount;
            document.getElementById('errorCount').textContent = errorCount;
        }

        function displayResults() {
            resultsSection.style.display = 'block';
            resultsContainer.innerHTML = '';

            results.forEach((result, index) => {
                const resultItem = document.createElement('div');
                resultItem.className = result.success ? 'result-item success' : 'result-item error';
                resultItem.id = `result-${index}`;

                if (result.success) {
                    resultItem.innerHTML = `
                        <div class="result-url">${result.url}</div>
                        <div class="result-status success">✓ Ready to Download</div>
                        <div class="result-actions">
                            <button class="btn-small" onclick="viewImage('${result.screenshot}')">Preview</button>
                            <button class="btn-small primary" id="download-btn-${index}" onclick="downloadWithLoading(${index})">
                                <span class="btn-text">
                                    <span id="btn-label-${index}">Download</span>
                                    <span class="progress-info" id="progress-info-${index}" style="display: none;"></span>
                                </span>
                                <div class="progress-bar-inline" id="progress-bar-${index}"></div>
                            </button>
                        </div>
                    `;
                } else {
                    resultItem.innerHTML = `
                        <div class="result-url">${result.url}</div>
                        <div class="result-status error">✗ Failed</div>
                        <div class="error-message">${result.error}</div>
                        <div class="result-actions">
                            <button class="btn-small" onclick="retryDownload(${index})">Retry</button>
                        </div>
                    `;
                }

                resultsContainer.appendChild(resultItem);
            });

            // Smooth scroll to results after a short delay
            setTimeout(() => {
                resultsSection.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
            }, 300);
        }

        async function downloadWithLoading(index) {
            const result = results[index];
            const btn = document.getElementById(`download-btn-${index}`);
            const btnLabel = document.getElementById(`btn-label-${index}`);
            const progressInfo = document.getElementById(`progress-info-${index}`);
            const progressBar = document.getElementById(`progress-bar-${index}`);
            const filename = sanitizeFilename(result.url);
            
            btn.disabled = true;
            btn.classList.add('loading');
            btnLabel.textContent = 'Downloading';
            progressInfo.style.display = 'inline';
            
            // Total methods to try
            const totalMethods = 6; // Direct + 3 Proxies + Canvas + Blob
            let currentMethod = 0;
            
            // Progress callback
            const progressCallback = (method, status, elapsed) => {
                if (status === 'trying') {
                    currentMethod++;
                    const progress = (currentMethod / totalMethods * 100);
                    progressBar.style.width = progress + '%';
                    
                    // Shorten method names for button display
                    let shortMethod = method;
                    if (method.includes('Direct')) shortMethod = 'Direct';
                    else if (method.includes('Proxy')) shortMethod = method;
                    else if (method.includes('Canvas')) shortMethod = 'Canvas';
                    else if (method.includes('Blob')) shortMethod = 'Blob';
                    
                    progressInfo.textContent = `${shortMethod} • ${elapsed}s`;
                } else if (status === 'success') {
                    progressBar.style.width = '100%';
                    progressBar.style.background = 'rgba(16, 185, 129, 0.8)';
                } else if (status === 'failed') {
                    // Continue progress for next method
                }
            };
            
            try {
                const downloadResult = await downloadImage(result.screenshot, filename, SETTINGS.retryCount, progressCallback);
                
                if (downloadResult.success) {
                    btnLabel.textContent = '✓ Done';
                    progressInfo.textContent = 'Success';
                    progressBar.style.width = '100%';
                    progressBar.style.background = 'rgba(16, 185, 129, 0.8)';
                    btn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                    
                    setTimeout(() => {
                        btnLabel.textContent = 'Download';
                        progressInfo.style.display = 'none';
                        progressInfo.textContent = '';
                        progressBar.style.width = '0%';
                        progressBar.style.background = 'rgba(255, 255, 255, 0.5)';
                        btn.style.background = 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)';
                        btn.disabled = false;
                        btn.classList.remove('loading');
                    }, 2000);
                } else {
                    throw new Error(downloadResult.error);
                }
            } catch (error) {
                btnLabel.textContent = '✗ Failed';
                progressInfo.textContent = 'Error';
                progressBar.style.width = '100%';
                progressBar.style.background = 'rgba(239, 68, 68, 0.8)';
                btn.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
                
                const resultItem = document.getElementById(`result-${index}`);
                const existingError = resultItem.querySelector('.error-message');
                if (!existingError) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error-message';
                    errorDiv.textContent = error.message;
                    resultItem.appendChild(errorDiv);
                }
                
                setTimeout(() => {
                    btnLabel.textContent = 'Retry';
                    progressInfo.style.display = 'none';
                    progressInfo.textContent = '';
                    progressBar.style.width = '0%';
                    progressBar.style.background = 'rgba(255, 255, 255, 0.5)';
                    btn.style.background = 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)';
                    btn.disabled = false;
                    btn.classList.remove('loading');
                }, 3000);
            }
        }

        async function retryDownload(index) {
            const result = results[index];
            const resultItem = document.getElementById(`result-${index}`);
            
            resultItem.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">Retrying...</div>';
            
            try {
                results[index] = {
                    url: result.url,
                    screenshot: result.url,
                    type: 'direct',
                    success: true
                };
                
                updateStats();
                displayResults();
                
            } catch (error) {
                results[index].error = error.message;
                displayResults();
            }
        }

        async function downloadAll() {
            const successResults = results.filter(r => r.success);
            
            if (successResults.length === 0) {
                alert('No successful results to download');
                return;
            }

            if (!confirm(`Download ${successResults.length} images as ZIP?\n\nNote: Some may fail due to server restrictions.`)) {
                return;
            }

            downloadAllBtn.disabled = true;
            downloadAllBtn.textContent = 'Preparing ZIP...';
            downloadAllBtn.classList.add('loading');

            try {
                const zip = new JSZip();
                let successCount = 0;
                let failCount = 0;
                const timeoutMs = SETTINGS.timeout * 1000;
                
                for (let i = 0; i < successResults.length; i++) {
                    const result = successResults[i];
                    const filename = sanitizeFilename(result.url);
                    
                    downloadAllBtn.textContent = `Adding ${i + 1}/${successResults.length}...`;
                    
                    let blob = null;
                    
                    try {
                        const response = await fetchWithTimeout(result.screenshot, {
                            mode: 'cors',
                            credentials: 'omit'
                        }, timeoutMs);
                        
                        if (response.ok) {
                            blob = await response.blob();
                        }
                    } catch (e) {}
                    
                    if (!blob || blob.size === 0) {
                        for (let proxy of CORS_PROXIES) {
                            try {
                                const response = await fetchWithTimeout(proxy(result.screenshot), {}, timeoutMs);
                                if (response.ok) {
                                    blob = await response.blob();
                                    if (blob.size > 0) break;
                                }
                            } catch (e) {
                                continue;
                            }
                        }
                    }
                    
                    if (blob && blob.size > 0) {
                        zip.file(filename, blob);
                        successCount++;
                    } else {
                        failCount++;
                    }
                }

                if (successCount === 0) {
                    alert('Failed to prepare ZIP. Try downloading individually.');
                    downloadAllBtn.disabled = false;
                    downloadAllBtn.textContent = 'Download All as ZIP';
                    downloadAllBtn.classList.remove('loading');
                    return;
                }

                downloadAllBtn.textContent = 'Generating ZIP...';
                const content = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });
                
                saveAs(content, `images_${Date.now()}.zip`);
                
                alert(`✓ ZIP created successfully!\n\nSuccess: ${successCount}\nFailed: ${failCount}\nTotal: ${successResults.length}`);
                
            } catch (error) {
                alert('Error creating ZIP: ' + error.message);
            }

            downloadAllBtn.disabled = false;
            downloadAllBtn.textContent = 'Download All as ZIP';
            downloadAllBtn.classList.remove('loading');
        }

        convertBtn.addEventListener('click', convertURLs);
        
        clearBtn.addEventListener('click', () => {
            if (isProcessing && !confirm('Processing in progress. Clear anyway?')) {
                return;
            }
            
            urlInput.value = '';
            resultsContainer.innerHTML = '';
            resultsSection.style.display = 'none';
            progressSection.style.display = 'none';
            results = [];
            isProcessing = false;
            convertBtn.disabled = false;
            autoResizeTextarea(); // Reset height
        });
        
        downloadAllBtn.addEventListener('click', downloadAll);

        // Auto-resize textarea
        function autoResizeTextarea() {
            urlInput.style.height = 'auto';
            const lineHeight = 1.8 * 14; // line-height * font-size
            const padding = 50; // top + bottom padding
            const lines = urlInput.value.split('\n').length;
            const minLines = 3;
            const maxLines = 20;
            
            const targetLines = Math.min(Math.max(lines, minLines), maxLines);
            const newHeight = (targetLines * lineHeight) + padding;
            
            urlInput.style.height = newHeight + 'px';
        }

        // Listen to textarea input
        urlInput.addEventListener('input', autoResizeTextarea);
        urlInput.addEventListener('paste', () => {
            setTimeout(autoResizeTextarea, 10);
        });

        // Initialize textarea height
        autoResizeTextarea();

        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                convertURLs();
            }
        });

        console.log('%c✨ URL to JPG Converter Ready', 'font-size: 16px; color: #6366f1; font-weight: bold;');
        console.log('%cDynamic delay: 1s (<10 URLs) | 2s (10+ URLs)', 'color: #888;');
        console.log('%cTimeout: 15s | Retry: 2x', 'color: #888;');
    </script>
</body>
</html>
